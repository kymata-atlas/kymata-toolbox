{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"getting-started/","title":"Getting started with Kymata Core","text":""},{"location":"getting-started/#set-up","title":"Set Up","text":"<p>This provides an overview of how to set up Kymata Core locally.</p> <p>Please be aware that this codebase is released publicly to ensure the transparency of the results in the Kymata Atlas. While  we welcome users using this codebase, we are unable to prioritise installation support.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python</li> </ul> <p>Confirm you have the correct version of Python installed. Type    <pre><code>$ pyenv versions\n</code></pre>    This should confirm that python 3.11 or above is installed. If it isn't already there,    install it using <code>pyenv install</code>. You should be able to confirm    you are using the correct version using    <pre><code>$ python -V\n</code></pre></p> <ul> <li>Poetry</li> </ul> <p>This package uses Poetry to manage packages. See python-poetry.org for installation instructions.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<ol> <li>Clone this repository:    <pre><code>$ git clone https://github.com/kymata-atlas/kymata-core.git\n</code></pre></li> <li> <p>To install the python packages you will need to use Poetry. Assuming you have installed Poetry,     type:    <pre><code>$ poetry install\n</code></pre>    to load the pakages needed.</p> </li> <li> <p>At this point, you should be able to either run the xx from the terminal    <pre><code>$ poetry run invokers/run_gridsearch.py\n</code></pre>    or activate in this environment in an IDE such as PyCharm.</p> </li> </ol>"},{"location":"getting-started/#running-tests-linting-and-generating-documentation","title":"Running tests, linting, and generating documentation","text":"<p>This will be done automatically via Github actions.</p> <p>To run the tests manually, run: <pre><code>$ poetry run pytest\n</code></pre> To run linting manually, run: <pre><code>$ poetry run ruff check\n</code></pre> To serve the documentation locally, run: <pre><code>$ poetry run mkdocs serve check\n</code></pre></p>"},{"location":"getting-started/#analysing-a-dataset-with-kymata","title":"Analysing a dataset with Kymata","text":""},{"location":"getting-started/#1-locate-your-raw-emeg-dataset","title":"1. Locate your raw EMEG dataset","text":"<p>You'll need the following files:</p> <ul> <li><code>&lt;participant_name&gt;_run1_raw.fif</code></li> <li><code>&lt;participant_name&gt;_recording_config.yaml</code></li> </ul>"},{"location":"getting-started/#2-preprocess-the-data","title":"2. Preprocess the data","text":"<p>Kymata Core holds the Kymata preprocessing code that comprises the 'Kymata back-end', including preprocessing steps, gridsearch procedures, expression plotting and IPPM generation.</p> <p>Run the following invokers from <code>invokers/</code> in order:</p> <ul> <li><code>invoker_run_data_cleansing.py</code></li> <li>This does:<ol> <li>first-pass filtering </li> <li>maxfiltering</li> <li>second-pass filtering</li> <li>eog removal</li> </ol> </li> <li><code>invoker_create_trialwise_data.py</code></li> <li>This does:<ol> <li>Splits the data into trials</li> </ol> </li> <li>This is all you need for sensor-space gridsearch.</li> <li><code>invoker_run_hexel_current_estimation.py</code></li> <li><code>invoker_estimate_noise_covariance.py</code></li> <li>This is only necessary if running the gridsearch in source space (hexels).</li> </ul>"},{"location":"getting-started/#3-run-the-gridsearch","title":"3. Run the gridsearch","text":"<p>Run the following invoker from invokers/:</p> <pre><code>invokers/run_gridsearch.py\n</code></pre> <p>This will output a <code>.nkg</code> file, which can then be loaded (see <code>demos/demo_save_load.ipynb</code>).</p> <p>Notes</p> <p>If running at the CBU, an easier way to do this (see Troubleshooting) may be to use the shell script <code>submit_gridsearch.sh</code>, which sets up the Apptainer environment the right way. Either run it locally with <code>./submit_gridsearch.sh</code>, or run it on the CBU queue with <code>sbatch submit_gridsearch.sh</code>.</p>"},{"location":"getting-started/#4-plot-the-results","title":"4. Plot the results","text":"<ul> <li><code>invoker_run_nkg_plotting.py</code></li> </ul> <p>See also <code>demos/demo_plotting.ipynb</code>.</p>"},{"location":"getting-started/#5-visualise-processing-pathways","title":"5. Visualise processing pathways","text":"<p>See <code>demos/demo_ippm.ipynb</code>.</p>"},{"location":"getting-started/#troubleshooting-on-the-cbu-compute-cluster","title":"Troubleshooting on the CBU compute cluster","text":"<p>You see <code>pyenv: Command not found</code>, <code>poetry: Command not found</code></p> <ul> <li>On the CBU nodes, <code>pyenv</code> only works in <code>bash</code>, so make sure you are using this.</li> </ul> <pre><code>bash\n</code></pre> <p>You see <code>/lib64/libm.so.6: version 'GLIBC_2.29' not found</code> when running gridsearch</p> <ul> <li>You are running it on a cbu node that does not have the right libraries installed. You could try it on a node which does (such as <code>lws-gpu02</code>), or (prefered) use <code>submit_gridsearch.sh</code> which will implement apptainer which layers the right libraries over the top of the node. </li> </ul> <p>You see <code>ModuleNotFoundError: No module named 'numpy'</code></p> <ul> <li>You are probably running <code>submit_gridsearch.sh</code>, and it currently has Andy's <code>kymata-core</code> location hard-coded. Update to point it at your copy.</li> </ul> <p>You see <code>ModuleNotFoundError: No module named 'kymata'</code></p> <ul> <li>You're not using the poetry environment.  You'll need to run this with Apptainer. First make sure <code>kymata-core</code> is installed with <code>poetry</code>, so the <code>kyamata</code> package is available within the virtual environment:</li> </ul> <pre><code>apptainer shell -B /imaging/projects/cbu/kymata /imaging/local/software/singularity_images/python/python_3.11.7-slim.sif\nexport VENV_PATH=~/poetry/\ncd /path/to/kymata-core\n\n# Allow the CBU poetry to communicate with pip\nexport PYTHON_KEYRING_BACKEND=keyring.backends.null.Keyring\n\n$VENV_PATH/bin/poetry install\n</code></pre> <ul> <li>Now (within the Apptainer) you can run it using <code>poetry</code>, e.g.:</li> </ul> <pre><code>$VENV_PATH/bin/poetry run python invokers/invoker_create_trialwise_data.py\n</code></pre>"},{"location":"overview/","title":"Overview of Kymata Core","text":"<p>Kymata Core is the central codebase used for the generation and maintenance of the Kymata Atlas, kymata.org. It is released as open source in order to maintain openness and transparency in scientific research, and is maintained by the Kymata Research Group.</p> <p>It is comprised of both a python package, <code>kymata</code>, and a number of invokers that instantiate the main Kymata Atlas pipeline, including:</p> <ul> <li>Standard preprocessing and source localisation steps for neural sensor data (MEG, EEG, ECoG);</li> <li>Gridsearch approaches for function mapping;</li> <li>Information Processing Pathway Map generation (both offline generation and evaluation);</li> <li>Plotting functionality</li> </ul> <p>The codebase is released publicly to ensure the transparency of the results in the Atlas. While comments and issues are welcomed, we are unable to prioritise installation support.</p> <p>  Go to the Github repository Go to code documentation</p>"},{"location":"overview/#citing-the-codebase-or-the-kymata-package","title":"Citing the codebase or the <code>kymata</code> package","text":"<p>Please use the following reference in all citations: </p> <p>TBC</p>"},{"location":"overview/#usage","title":"Usage","text":"<p>Please refer to the documentation, or see the <code>demos/</code> folder for example code, including test data.</p>"},{"location":"reference/","title":"Code Reference","text":""},{"location":"reference/#kymata","title":"kymata","text":""},{"location":"reference/#kymata.plot.plot","title":"kymata.plot.plot","text":""},{"location":"reference/#kymata.plot.plot.expression_plot","title":"expression_plot","text":"<pre><code>expression_plot(expression_set: ExpressionSet, show_only: Optional[str | Sequence[str]] = None, paired_axes: bool = True, alpha: float = 1 - NormalDist(mu=0, sigma=1).cdf(5), color: Optional[str | dict[str, str] | list[str]] = None, ylim: Optional[float] = None, xlims: tuple[Optional[float], Optional[float]] = (-100, 800), hidden_functions_in_legend: bool = True, minimap: bool = False, minimap_view: str = 'lateral', minimap_surface: str = 'inflated', save_to: Optional[Path] = None, overwrite: bool = True, show_legend: bool = True, legend_display: dict[str, str] | None = None) -&gt; Figure\n</code></pre> <p>Generates a plot of function expressions over time with optional display customizations.</p> <p>Parameters:</p> <ul> <li> <code>expression_set</code>               (<code>ExpressionSet</code>)           \u2013            <p>The set of expressions to plot, containing functions and associated data.</p> </li> <li> <code>show_only</code>               (<code>Optional[str | Sequence[str]]</code>, default:                   <code>None</code> )           \u2013            <p>A string or a sequence of strings specifying which functions to plot. If None, all functions in the expression_set will be plotted. Default is None.</p> </li> <li> <code>paired_axes</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>When True, shows the expression plot split into left and right axes. When False, all points are shown on the same axis. Default is True.</p> </li> <li> <code>alpha</code>               (<code>float</code>, default:                   <code>1 - cdf(5)</code> )           \u2013            <p>Significance level for statistical tests, defaulting to a 5-sigma threshold.</p> </li> <li> <code>color</code>               (<code>Optional[str | dict[str, str] | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Color settings for the plot. Can be a single color, a dictionary mapping function names to colors, or a list of colors. Default is None.</p> </li> <li> <code>ylim</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The y-axis limit. If None, it will be determined automatically. Default is None.</p> </li> <li> <code>xlims</code>               (<code>tuple[Optional[float], Optional[float]]</code>, default:                   <code>(-100, 800)</code> )           \u2013            <p>The x-axis limits as a tuple. None to use default values, or set either entry to None to use the default for that value. Default is (-100, 800).</p> </li> <li> <code>hidden_functions_in_legend</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, includes non-plotted functions in the legend. Default is True.</p> </li> <li> <code>minimap</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, displays a minimap of the expression data. Default is False.</p> </li> <li> <code>minimap_view</code>               (<code>str</code>, default:                   <code>'lateral'</code> )           \u2013            <p>The view type for the minimap, either \"lateral\" or other specified views. Default is \"lateral\".</p> </li> <li> <code>minimap_surface</code>               (<code>str</code>, default:                   <code>'inflated'</code> )           \u2013            <p>The surface type for the minimap, such as \"inflated\". Default is \"inflated\".</p> </li> <li> <code>save_to</code>               (<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to save the generated plot. If None, the plot is not saved. Default is None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, overwrite the existing file if it exists. Default is True.</p> </li> <li> <code>show_legend</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, displays the legend. Default is True.</p> </li> <li> <code>legend_display</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Allows grouping of multiple functions under the same legend item. Provide a dictionary mapping true function names to display names. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>pyplot.Figure: The matplotlib figure object containing the generated plot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If the file already exists at save_to and overwrite is set to False.</p> </li> </ul> Notes <p>The function plots the expression data with options to customize the appearance and statistical significance thresholds. It supports different data types (e.g., HexelExpressionSet, SensorExpressionSet) and can handle paired axes for left/right hemisphere data.</p>"},{"location":"reference/#kymata.plot.plot.hide_axes","title":"hide_axes","text":"<pre><code>hide_axes(axes: Axes)\n</code></pre> <p>Hide all axes markings from a pyplot.Axes.</p>"},{"location":"reference/#kymata.plot.plot.legend_display_dict","title":"legend_display_dict","text":"<pre><code>legend_display_dict(functions: list[str], display_name) -&gt; dict[str, str]\n</code></pre> <p>Creates a dictionary for the <code>legend_display</code> parameter of <code>expression_plot()</code>.</p> <p>This function maps each function name in the provided list to a single display name, which can be used to group multiple functions under one legend item in the plot.</p> <p>Parameters:</p> <ul> <li> <code>functions</code>               (<code>list[str]</code>)           \u2013            <p>A list of function names to be grouped under the same display name.</p> </li> <li> <code>display_name</code>               (<code>str</code>)           \u2013            <p>The display name to be used for all functions in the list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary mapping each function name to the provided display name.</p> </li> </ul>"},{"location":"reference/#kymata.plot.plot.plot_top_five_channels_of_gridsearch","title":"plot_top_five_channels_of_gridsearch","text":"<pre><code>plot_top_five_channels_of_gridsearch(latencies: NDArray[any], corrs: NDArray[any], function: Function, n_samples_per_split: int, n_reps: int, n_splits: int, auto_corrs: NDArray[any], log_pvalues: any, save_to: Optional[Path] = None, overwrite: bool = True)\n</code></pre> <p>Generates correlation and p-value plots showing the top five channels of the gridsearch.</p> <p>Parameters:</p> <ul> <li> <code>latencies</code>               (<code>NDArray[any]</code>)           \u2013            <p>Array of latency values (e.g., time points in milliseconds) for the x-axis of the plots.</p> </li> <li> <code>corrs</code>               (<code>NDArray[any]</code>)           \u2013            <p>Correlation coefficients array with shape (n_channels, n_conditions, n_splits, n_time_steps).</p> </li> <li> <code>function</code>               (<code>Function</code>)           \u2013            <p>The function object whose name attribute will be used in the plot title.</p> </li> <li> <code>n_samples_per_split</code>               (<code>int</code>)           \u2013            <p>Number of samples per split used in the grid search.</p> </li> <li> <code>n_reps</code>               (<code>int</code>)           \u2013            <p>Number of repetitions in the grid search.</p> </li> <li> <code>n_splits</code>               (<code>int</code>)           \u2013            <p>Number of splits in the grid search.</p> </li> <li> <code>auto_corrs</code>               (<code>NDArray[any]</code>)           \u2013            <p>Auto-correlation values array used for plotting the function auto-correlation.</p> </li> <li> <code>log_pvalues</code>               (<code>any</code>)           \u2013            <p>Array of log-transformed p-values for each channel and time point.</p> </li> <li> <code>save_to</code>               (<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to save the generated plot. If None, the plot is not saved. Default is None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, overwrite the existing file if it exists. Default is True.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If the file already exists at save_to and overwrite is set to False.</p> </li> </ul> Notes <p>The function generates two subplots:</p> <ul> <li>The first subplot shows the correlation coefficients over latencies for the top five channels.</li> <li>The second subplot shows the corresponding p-values for these channels.</li> </ul>"},{"location":"reference/#kymata.gridsearch.plain","title":"kymata.gridsearch.plain","text":""},{"location":"reference/#kymata.gridsearch.plain.do_gridsearch","title":"do_gridsearch","text":"<pre><code>do_gridsearch(emeg_values: NDArray, function: Function, channel_names: list, channel_space: str, start_latency: float, emeg_t_start: float, stimulus_shift_correction: float, stimulus_delivery_latency: float, plot_location: Optional[Path] = None, emeg_sample_rate: int = 1000, n_derangements: int = 1, seconds_per_split: float = 1, n_splits: int = 400, n_reps: int = 1, overwrite: bool = True) -&gt; ExpressionSet\n</code></pre> <p>Perform a grid search over all hexels for all latencies using EMEG data and a given function.</p> <p>This function processes EMEG data to compute the correlation between sensor or source signals and a specified function across multiple latencies. The results include statistical significance testing and optional plotting.</p> <p>Parameters:</p> <ul> <li> <code>emeg_values</code>               (<code>NDArray</code>)           \u2013            <p>A 2D array of EMEG values with shape (n_channels, time).</p> </li> <li> <code>function</code>               (<code>Function</code>)           \u2013            <p>The function against which the EMEG data will be correlated. It should have a <code>values</code> attribute representing the function's values and a <code>sample_rate</code> attribute indicating its sample rate.</p> </li> <li> <code>channel_names</code>               (<code>list</code>)           \u2013            <p>List of channel names corresponding to the EMEG data. For 'sensor' space, it is a flat list of sensor names. For 'source' space, it is a list containing two lists: left hemisphere and right hemisphere hexel names.</p> </li> <li> <code>channel_space</code>               (<code>str</code>)           \u2013            <p>The type of channel space used, either 'sensor' or 'source'.</p> </li> <li> <code>start_latency</code>               (<code>float</code>)           \u2013            <p>The starting latency for the grid search in milliseconds.</p> </li> <li> <code>emeg_t_start</code>               (<code>float</code>)           \u2013            <p>The starting time of the EMEG data in milliseconds.</p> </li> <li> <code>stimulus_shift_correction</code>               (<code>float</code>)           \u2013            <p>Correction factor for stimulus shift in seconds per second.</p> </li> <li> <code>stimulus_delivery_latency</code>               (<code>float</code>)           \u2013            <p>Correction offset for stimulus delivery in seconds.</p> </li> <li> <code>plot_location</code>               (<code>Optional[Path]</code>, default:                   <code>None</code> )           \u2013            <p>Path to save the plot of the top five channels of the grid search. If None, plotting is skipped. Default is None.</p> </li> <li> <code>emeg_sample_rate</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>The sample rate of the EMEG data in Hertz. Default is 1000 Hz.</p> </li> <li> <code>n_derangements</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of derangements (random permutations) used to create the null distribution. Default is 1.</p> </li> <li> <code>seconds_per_split</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Duration of each split in seconds. Default is 0.5 seconds.</p> </li> <li> <code>n_splits</code>               (<code>int</code>, default:                   <code>400</code> )           \u2013            <p>Number of splits used for analysis. Default is 800.</p> </li> <li> <code>n_reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of repetitions for each split. Default is 1.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to overwrite existing plot files. Default is True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ExpressionSet</code> (              <code>ExpressionSet</code> )          \u2013            <p>An ExpressionSet object (either SensorExpressionSet or HexelExpressionSet)</p> </li> <li> <code>ExpressionSet</code>           \u2013            <p>containing the log p-values for each channel/hexel and latency.</p> </li> </ul> Notes <ul> <li>The function down-samples the EMEG data to match the function's sample rate.</li> <li>The EMEG data is reshaped into segments of the specified duration (<code>seconds_per_split</code>).</li> <li>Cross-correlations between the EMEG data and the function are computed using FFT.</li> <li>Statistical significance is assessed using a vectorized Welch's t-test.</li> <li>If specified, the results are plotted and saved to the given location.</li> </ul>"},{"location":"reference/#kymata.io.nkg","title":"kymata.io.nkg","text":""},{"location":"reference/#kymata.io.nkg.load_expression_set","title":"load_expression_set","text":"<pre><code>load_expression_set(from_path_or_file: PathType | FileType) -&gt; ExpressionSet\n</code></pre> <p>Loads an ExpressionSet from the specified path or file.</p> <p>The function determines the type of ExpressionSet (HexelExpressionSet or SensorExpressionSet) based on the data loaded from the provided path or file. It then constructs and returns an instance of the appropriate ExpressionSet subclass.</p> <p>Parameters:</p> <ul> <li> <code>from_path_or_file</code>               (<code>PathType | FileType</code>)           \u2013            <p>The path or file from which to load the data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ExpressionSet</code> (              <code>ExpressionSet</code> )          \u2013            <p>An instance of either HexelExpressionSet or SensorExpressionSet,                depending on the type identifier in the data.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If required keys are missing in the data dictionary.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the type identifier is not recognized.</p> </li> </ul>"},{"location":"reference/#kymata.io.nkg.save_expression_set","title":"save_expression_set","text":"<pre><code>save_expression_set(expression_set: ExpressionSet, to_path_or_file: PathType | FileType, compression=ZIP_LZMA, overwrite: bool = False)\n</code></pre> <p>Save the given ExpressionSet to a specified path or an already open file.</p> <p>This function saves the ExpressionSet data into a compressed file format. If a file path is provided, it creates and writes to the file. If an open file is supplied, it should be opened in \"wb\" mode. The overwrite flag is ignored if an open file is supplied.</p> <p>Parameters:</p> <ul> <li> <code>expression_set</code>               (<code>ExpressionSet</code>)           \u2013            <p>The ExpressionSet object to be saved.</p> </li> <li> <code>to_path_or_file</code>               (<code>PathType | FileType</code>)           \u2013            <p>The path or open file where the ExpressionSet will be saved.</p> </li> <li> <code>compression</code>           \u2013            <p>The compression method to use (default is ZIP_LZMA).</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allows overwriting an existing file (default is False).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If the specified path already exists and overwrite is False.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the provided path or file type is invalid.</p> </li> </ul> Notes <ul> <li>The compression parameter should be compatible with the <code>ZipFile</code> class.</li> <li>The function writes various metadata and data blocks in a structured format within the zip file.</li> </ul>"},{"location":"reference/#kymata.io.config","title":"kymata.io.config","text":""},{"location":"reference/#kymata.io.config.get_root_dir","title":"get_root_dir","text":"<pre><code>get_root_dir(config: dict) -&gt; str\n</code></pre> <p>Get the root directory based on the configuration parameters.</p> <p>This function returns the appropriate root directory path based on the 'data_location' parameter in the provided configuration dictionary.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>dict</code>)           \u2013            <p>The configuration dictionary containing the 'data_location' parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The root directory path corresponding to the 'data_location' parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the 'data_location' parameter is not 'local', 'cbu', or 'cbu-local'.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.load_config","title":"load_config","text":"<pre><code>load_config(config_location: PathType | FileType)\n</code></pre> <p>Load configuration parameters from a specified path or file.</p> <p>This function reads the configuration parameters from a YAML file located at the given path or open file.</p> <p>Parameters:</p> <ul> <li> <code>config_location</code>               (<code>PathType | FileType</code>)           \u2013            <p>The path to the configuration file or an open file object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>          \u2013            <p>The configuration parameters loaded from the file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the specified path does not exist.</p> </li> <li> <code>YAMLError</code>             \u2013            <p>If there is an error in parsing the YAML file.</p> </li> </ul>"},{"location":"reference/#kymata.io.config.modify_param_config","title":"modify_param_config","text":"<pre><code>modify_param_config(config_location: str, key: str, value)\n</code></pre> <p>Modify a specific configuration parameter in the given configuration file.</p> <p>This function updates the value of a specified key in the configuration file and saves the changes.</p> <p>Parameters:</p> <ul> <li> <code>config_location</code>               (<code>str</code>)           \u2013            <p>The path to the configuration file.</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the configuration parameter to be modified.</p> </li> <li> <code>value</code>           \u2013            <p>The new value to be assigned to the specified key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the specified configuration file does not exist.</p> </li> <li> <code>YAMLError</code>             \u2013            <p>If there is an error in parsing the YAML file.</p> </li> </ul>"},{"location":"reference/#kymata.ippm.plotter","title":"kymata.ippm.plotter","text":""},{"location":"reference/#kymata.ippm.plotter.IPPMPlotter","title":"IPPMPlotter","text":"<p>               Bases: <code>object</code></p>"},{"location":"reference/#kymata.ippm.plotter.IPPMPlotter.draw","title":"draw","text":"<pre><code>draw(graph: Dict[str, Node], colors: Dict[str, str], title: str, figheight: int = 5, figwidth: int = 10)\n</code></pre> <p>Generates an acyclic, directed graph using the graph held in graph. Edges are generated using BSplines.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Dict[str, Node]</code>)           \u2013            <p>Dictionary with keys as node names and values as Hexel objects. Contains nodes as keys and magnitude, position, and incoming edges in the Hexel object.</p> </li> <li> <code>colors</code>               (<code>Dict[str, str]</code>)           \u2013            <p>Dictionary with keys as node names and values as colors in hexadecimal. Contains the color for each function. The nodes and edges are colored accordingly.</p> </li> <li> <code>title</code>               (<code>str</code>)           \u2013            <p>Title of the plot.</p> </li> <li> <code>figheight</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Height of the plot. Defaults to 5.</p> </li> <li> <code>figwidth</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Width of the plot. Defaults to 10.</p> </li> </ul>"},{"location":"reference/#kymata.ippm.builder","title":"kymata.ippm.builder","text":""},{"location":"reference/#kymata.ippm.builder.IPPMBuilder","title":"IPPMBuilder","text":"<p>               Bases: <code>object</code></p> <p>A graphing class used to construct a dictionary that contains the nodes and all relevant information to construct a dict containing node names as keys and Node objects (see namedtuple) as values.</p>"},{"location":"reference/#kymata.ippm.builder.IPPMBuilder.build_graph","title":"build_graph","text":"<pre><code>build_graph(hexels: Dict[str, IPPMHexel], function_hier: Dict[str, List[str]], inputs: List[str], hemi: str) -&gt; Dict[str, Node]\n</code></pre> <p>Builds a dictionary of nodes and information about the node. The information is built out of namedtuple class Node, which contains magnitude, position, color, and the incoming edges.</p> <p>Parameters:</p> <ul> <li> <code>hexels</code>               (<code>Dict[str, IPPMHexel]</code>)           \u2013            <p>Dictionary containing function names and Hexel objects with data in it.</p> </li> <li> <code>function_hier</code>               (<code>Dict[str, List[str]]</code>)           \u2013            <p>Dictionary of the format {function_name: [parent_functions]}.</p> </li> <li> <code>inputs</code>               (<code>List[str]</code>)           \u2013            <p>List of input functions. function_hier contains the input functions, so we need this                 to distinguish between inputs and functions.</p> </li> <li> <code>hemi</code>               (<code>str</code>)           \u2013            <p>'leftHemisphere' or 'rightHemisphere'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Node]</code>           \u2013            <p>Dict[str, Node]: A dictionary of nodes with unique names where the keys are node objects with all              relevant information for plotting a graph.</p> </li> </ul> Analysis <p>The overall complexity of the algorithm is O(f * nlogn) where:</p> <ul> <li>f is the number of functions.</li> <li>n is the number of hexels.</li> </ul> <p>The sorting step takes O(f * nlogn).</p> <p>Looping through functions and parents contributes O(f * n + f^2).</p> <p>Space Complexity:</p> <ul> <li>Total space complexity is O(f * n), which includes copies of hexels and function hierarchy.</li> </ul> <p>The analysis section provides detailed reasoning for the complexities.</p> Algorithm <p>The algorithm iteratively selects the top-level function, defined as a function that does not have any children (no outgoing arrows). It starts with the final function and proceeds in a top-down fashion towards the input node. Each selected top-level function creates a spike for every pairing in the best_pairings. Edges are added from the final function of each parent to the first current function, repeating for all functions. The input node is treated differently with a default size of 10 at latency 0.</p>"},{"location":"reference/#kymata.entities.expression","title":"kymata.entities.expression","text":"<p>Classes and functions for storing expression information.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet","title":"ExpressionSet","text":"<pre><code>ExpressionSet(functions: str | Sequence[str], latencies: Sequence[Latency], data_blocks: dict[str, _InputDataArray | Sequence[_InputDataArray]], channel_coord_name: str, channel_coord_dtype, channel_coord_values: dict[str, Sequence])\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Brain data associated with expression of a single function. Data is log10 p-values</p> <p>data_blocks' values should store log10 p-values</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: list[FunctionNameDType]\n</code></pre> <p>Function names.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.best_functions","title":"best_functions  <code>abstractmethod</code>","text":"<pre><code>best_functions() -&gt; DataFrame | tuple[DataFrame, ...]\n</code></pre> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.ExpressionSet.rename","title":"rename","text":"<pre><code>rename(functions: dict[str, str]) -&gt; None\n</code></pre> <p>Renames the functions within an ExpressionSet.</p> <p>Supply a dictionary mapping old function names to new function names.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a function name in the expression set.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet","title":"HexelExpressionSet","text":"<pre><code>HexelExpressionSet(functions: str | Sequence[str], hexels_lh: Sequence[Hexel], hexels_rh: Sequence[Hexel], latencies: Sequence[Latency], data_lh: _InputDataArray | Sequence[_InputDataArray], data_rh: _InputDataArray | Sequence[_InputDataArray])\n</code></pre> <p>               Bases: <code>ExpressionSet</code></p> <p>Brain data associated with expression of a single function in hexel space. Includes lh, rh, flipped, non-flipped. Data is log10 p-values</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: list[FunctionNameDType]\n</code></pre> <p>Function names.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.hexels_left","title":"hexels_left  <code>property</code>","text":"<pre><code>hexels_left: NDArray[HexelDType]\n</code></pre> <p>Hexels, canonical ID.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.hexels_right","title":"hexels_right  <code>property</code>","text":"<pre><code>hexels_right: NDArray[HexelDType]\n</code></pre> <p>Hexels, canonical ID.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.left","title":"left  <code>property</code>","text":"<pre><code>left: DataArray\n</code></pre> <p>Left-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.right","title":"right  <code>property</code>","text":"<pre><code>right: DataArray\n</code></pre> <p>Right-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.best_functions","title":"best_functions","text":"<pre><code>best_functions() -&gt; Tuple[DataFrame, DataFrame]\n</code></pre> <p>Return a pair of DataFrames (left, right), containing: for each hexel, the best function and latency for that hexel, and the associated log p-value</p> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.HexelExpressionSet.rename","title":"rename","text":"<pre><code>rename(functions: dict[str, str]) -&gt; None\n</code></pre> <p>Renames the functions within an ExpressionSet.</p> <p>Supply a dictionary mapping old function names to new function names.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a function name in the expression set.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet","title":"SensorExpressionSet","text":"<pre><code>SensorExpressionSet(functions: str | Sequence[str], sensors: Sequence[Sensor], latencies: Sequence[Latency], data: _InputDataArray | Sequence[_InputDataArray])\n</code></pre> <p>               Bases: <code>ExpressionSet</code></p> <p>Brain data associated with the expression of a single function in sensor space. Includes left hemisphere (lh), right hemisphere (rh), flipped, and non-flipped data. Data is represented as log10 p-values.</p> <p>Initialize the SensorExpressionSet with function names, sensor metadata, latency information, and log p-value data.</p> <p>Parameters:</p> <ul> <li> <code>functions</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>The names of the functions being evaluated.</p> </li> <li> <code>sensors</code>               (<code>Sequence[Sensor]</code>)           \u2013            <p>Metadata about the sensors used in the study.</p> </li> <li> <code>latencies</code>               (<code>Sequence[Latency]</code>)           \u2013            <p>Latency information corresponding to the data.</p> </li> <li> <code>data</code>               (<code>_InputDataArray | Sequence[_InputDataArray]</code>)           \u2013            <p>Log p-values representing the data.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: list[FunctionNameDType]\n</code></pre> <p>Function names.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.latencies","title":"latencies  <code>property</code>","text":"<pre><code>latencies: NDArray[LatencyDType]\n</code></pre> <p>Latencies, in seconds.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.scalp","title":"scalp  <code>property</code>","text":"<pre><code>scalp: DataArray\n</code></pre> <p>Get the left-hemisphere data.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.sensors","title":"sensors  <code>property</code>","text":"<pre><code>sensors: NDArray[SensorDType]\n</code></pre> <p>Get the sensor metadata.</p> <p>Returns:</p> <ul> <li> <code>NDArray[SensorDType]</code>           \u2013            <p>NDArray[SensorDType]: Array of sensor metadata.</p> </li> </ul>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.best_functions","title":"best_functions","text":"<pre><code>best_functions() -&gt; DataFrame\n</code></pre> <p>Return a DataFrame containing: for each sensor, the best function and latency for that sensor, and the associated log p-value</p> <p>Note that channels for which the best p-value is 1 will be omitted.</p>"},{"location":"reference/#kymata.entities.expression.SensorExpressionSet.rename","title":"rename","text":"<pre><code>rename(functions: dict[str, str]) -&gt; None\n</code></pre> <p>Renames the functions within an ExpressionSet.</p> <p>Supply a dictionary mapping old function names to new function names.</p> <p>Raises KeyError if one of the keys in the renaming dictionary is not a function name in the expression set.</p>"}]}